= Principles

== RESTful API

The platform exposes all its functionality via a *practically-RESTful API*, that communicates using JSON.

We use the term *practically-RESTful* in order to make it clear we are not trying to be fully REST compliant but still maintain important RESTful attributes like:

* Stateless: platform maintains no conversational or session-based state. The result of this is ability to scale horizontally with ease.
* Resource-oriented: API is focussed around set of resources using HTTP vocabulary and conventions e.g GET, PUT, POST, DELETE, HTTP status codes. This results in a simple and consistent API for clients.

See online API Documentation for more detail.

== Multi-tenanted

The Fineract platform has been developed with support for multi-tenancy at the core of its design. This means that it is just as easy to use the platform for Software-as-a-Service (SaaS) type offerings as it is for local installations.

The platform uses an approach that isolates an FIs data per database/schema (See Separate Databases and Shared Database, Separate Schemas).

== Extensible

Whilst each tenant will have a set of core tables, the platform tables can be extended in different ways for each tenant through the use of Data tables functionality.

== Command Query Seperation

We seperate *commands* (that change data) from *queries* (that read data).

Why? There are numerous reasons for choosing this approach which at present is not an attempt at full blown CQRS. The main advantages at present are:

* State changing commands are persisted providing an audit of all state changes.
* Used to support a general approach to *maker-checker*.
* State changing commands use the Object-Oriented paradign (and hence ORM) whilst querys can stay in the data paradigm.

== Maker-Checker

Also known as *four-eyes principal*. Enables apps to support a maker-checker style workflow process. Commands that pass validation will be persisted. Maker-checker can be enabled/disabled at fine-grained level for any state changing API.
Fine grained access control

A fine grained permission is associated with each API. Administrators have fine grained control over what roles or users have access to.

== Package Structure

The intention is for platform code to be packaged in a vertical slice way (as opposed to layers).
Source code starts from https://github.com/apache/fineract/tree/develop/fineract-provider/src/main/java/org/apache/fineract

* accounting
* useradministration
* infrastructure
* portfolio
** charge
** client
** fund
** loanaccount
* accounting

Within each vertical slice is some common packaging structure:

* api - XXXApiResource.java - REST api implementation files
* handler - XXXCommandHandler.java - specific handlers invoked
* service - contains read + write services for functional area
* domain - OO concepts for the functional area
* data - Data concepts for the area
* serialization - ability to convert from/to API JSON for functional area


== Read/Write/Batch API Operation Separation

Fineract has three different instance types:

* Read instance
* Write instance
* Batch instance

In cases where Fineract has to deal with high load, it can cause a performance problem for a single Fineract instance. To overcome this problem, Fineract instances can be started in different instance types for better scalability and performance in a multi-instance environment:

Detailed documentation on instance types can be found in this document: https://github.com/apache/fineract/blob/develop/fineract-doc/src/docs/en/chapters/deployment/instance-type.adoc

The linked document also explains deployment steps and specifications.

=== Background

Instances, where we're planning to deploy Fineract to a highly-available setup with the highest-throughput because we can scale individual parts of it.


Reading data happens much more often than actually writing data so the ability to do this type of deployment will greatly improve what we can achieve in terms of performance.

Also, with the separation in place, we could utilize read-replica databases as well where write and batch instances connect to a master DB and the read instances connect to read-replicas therefore reducing the load on the database as well.

All three instances come with different types of restrictions in terms of what they are capable of. For example a read instance is going to be only capable of serving read (GET) APIs. Write APIs will be able to serve both read and write APIs. Batch instance is only able to serve batch job related APIs and run the batch jobs themselves.

=== Context

===== Instance types

**Read instance** only accepts `GET` request. Optionally, there are database connection details for this mode.

**Write instance** accepts `GET/POST/PUT/DELETE` requests. It uses the original database connection details.

**BATCH instance** accepts `POST` request related to run jobs. It will start the Quartz scheduler at startup time and run the batch jobs.

=== Modes

* Full mode (default)
* Read mode
* Write mode
* Batch mode

=== Setup

==== Environment Variable

Using environment variables, the three instance types performance enhancing operation separation can be performed:

* FINERACT_READ_MODE_ENABLED
* FINERACT_WRITE_MODE_ENABLED
* FINERACT_BATCH_MODE_ENABLED

These three are the boolean variables to enable or disable the instance modes.

=== Database Settings

Optional database connection details for reading mode are:

.Database connection settings
|===
^| Key ^| Type ^| Value

| schema_server | character varying (100) |  127.0.0.1
| schema_name | character varying (100) | fineract_default
| schema_server_port | character varying (10) | 5432
| schema_username | character varying (100) | mifosadmin
| schema_password | character varying (100) | password
| readonly_schema_server | character varying(100) | [null]
| readonly_schema_name | character varying(100) | [null]
| readonly_schema_server_port | character varying(10) | [null]
| readonly_schema_usernname | character varying (100) | [null]
| readonly_schema_password | character varying (100) | [null]
| readonly_schema_connection_parameters | text | [null]
|===

=== Use Case Scenarios

==== APIs

* Read APIs are allowed only for read and write instances
* Write APIs are allowed only for write instances
* Batch job APIs are allowed only for batch instances

==== Batch jobs

* Batch job scheduling is allowed only for batch instances

==== Read-only instance type restrictions

* Events are disabled for read-only instances
* Read-only tenant connection support

==== Batch-only instance type restrictions

* Receiving events is disabled for batch-only instances
